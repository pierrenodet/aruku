"use strict";(self.webpackChunkaruku=self.webpackChunkaruku||[]).push([[354],{3905:function(e,t,n){n.d(t,{Zo:function(){return u},kt:function(){return m}});var r=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},o=Object.keys(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var s=r.createContext({}),c=function(e){var t=r.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},u=function(e){var t=c(e.components);return r.createElement(s.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},d=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,o=e.originalType,s=e.parentName,u=l(e,["components","mdxType","originalType","parentName"]),d=c(n),m=a,k=d["".concat(s,".").concat(m)]||d[m]||p[m]||o;return n?r.createElement(k,i(i({ref:t},u),{},{components:n})):r.createElement(k,i({ref:t},u))}));function m(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=n.length,i=new Array(o);i[0]=d;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:a,i[1]=l;for(var c=2;c<o;c++)i[c]=n[c];return r.createElement.apply(null,i)}return r.createElement.apply(null,n)}d.displayName="MDXCreateElement"},6493:function(e,t,n){n.r(t),n.d(t,{assets:function(){return u},contentTitle:function(){return s},default:function(){return m},frontMatter:function(){return l},metadata:function(){return c},toc:function(){return p}});var r=n(7462),a=n(3366),o=(n(7294),n(3905)),i=["components"],l={id:"transition",title:"Transition Probability"},s=void 0,c={unversionedId:"transition",id:"transition",title:"Transition Probability",description:"Definition",source:"@site/../modules/aruku-docs/target/mdoc/transition.md",sourceDirName:".",slug:"/transition",permalink:"/aruku/docs/transition",draft:!1,editUrl:"https://github.com/pierrenodet/aruku/edit/main/modules/docs/transition.md",tags:[],version:"current",frontMatter:{id:"transition",title:"Transition Probability"},sidebar:"someSidebar",previous:{title:"Configuration",permalink:"/aruku/docs/configuration"},next:{title:"Provided Walks",permalink:"/aruku/docs/walks"}},u={},p=[{value:"Definition",id:"definition",level:2},{value:"Oblivious",id:"oblivious",level:2},{value:"Static",id:"static",level:2},{value:"Dynamic",id:"dynamic",level:2}],d={toc:p};function m(e){var t=e.components,n=(0,a.Z)(e,i);return(0,o.kt)("wrapper",(0,r.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h2",{id:"definition"},"Definition"),(0,o.kt)("p",null,"A transition probability is the probability of a random walker jumping to a node for the next step of his walk."),(0,o.kt)("p",null,"It's made of three key components :"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"Static Component : Reflects the edge component")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"Dynamic Component : Reflects the state of the walker")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"Extension Component : Reflects the termination of the walker"))),(0,o.kt)("h2",{id:"oblivious"},"Oblivious"),(0,o.kt)("p",null,"An oblivious walk contains only an extension component."),(0,o.kt)("p",null,"It's the most straightforward random walk possible as it doesn't follow any edge component or change during the walk."),(0,o.kt)("p",null,"For example, let's create a random walk that stops after ",(0,o.kt)("inlineCode",{parentName:"p"},"walkLength")," steps :"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},"import aruku._\nimport org.apache.spark.graphx._\n\ncase object ObliviousWalk {\n\n  def transition(walkLength: Long) =\n    Transition.oblivious(\n      (walker: Walker[ObliviousWalk.type], _: VertexId) => \n        if (walker.step < walkLength) 1.0 else 0.0\n    )\n\n}\n")),(0,o.kt)("h2",{id:"static"},"Static"),(0,o.kt)("p",null,"A static walk contains only an extension component and a static component."),(0,o.kt)("p",null,"It's a more realistic component, as often seen a real-world graph, the edge component matters to determine the strength of the link between two vertices."),(0,o.kt)("p",null,"Let's add a static component to our previous oblivious walk :"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},"import aruku._\nimport org.apache.spark.graphx._\n\ncase object StaticWalk {\n\n  def transition(walkLength: Long) =\n    Transition.static(\n      (walker: Walker[StaticWalk.type], _: VertexId) => \n        if (walker.step < walkLength) 1.0 else 0.0,\n      (vid: VertexId, edge: Edge[Double]) => edge.attr\n    )\n\n}\n")),(0,o.kt)("p",null,"Hey, we made DeepWalk !"),(0,o.kt)("h2",{id:"dynamic"},"Dynamic"),(0,o.kt)("p",null,"A dynamic walk contains all three components, extension, static and dynamic."),(0,o.kt)("p",null,"For a more elaborate random walk, the walker will decide to jump to the next node thanks to its internal state."),(0,o.kt)("p",null,"If we wanted to make node2vec, the transition probability would look like this :"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},"import aruku._\nimport org.apache.spark.graphx._\n\ncase class DynamicWalk(previous: VertexId)\n\nobject DynamicWalk {\n\n def transition(p: Double, q: Double, walkLength: Long) =\n\n    Transition.secondOrder(\n      (walker: Walker[DynamicWalk], _: VertexId) => if (walker.step < walkLength) 1.0 else 0.0,\n      (_: VertexId, edge: Edge[Double]) => edge.attr,\n      (walker: Walker[DynamicWalk], _: VertexId, edges: Array[Edge[Double]]) => Some(edges),\n      (\n        walker: Walker[DynamicWalk],\n        current: VertexId,\n        next: Edge[Double],\n        msg: Option[Array[Edge[Double]]]\n      ) =>\n        msg match {\n          case Some(previousNeighbors) =>\n            val dst = next.dstId\n            if (dst == walker.data.previous) {\n              1.0 / p\n            } else if (previousNeighbors.exists(_.dstId == dst)) {\n              1.0\n            } else {\n              1.0 / q\n            }\n          case None                    => 1.0\n        },\n      (_: VertexId, _: Array[Edge[Double]]) => math.max(1.0 / p, math.max(1.0, 1.0 / q)),\n      (_: VertexId, _: Array[Edge[Double]]) => math.min(1.0 / p, math.min(1.0, 1.0 / q))\n    )\n\n}\n")),(0,o.kt)("p",null,"As you can see, node2vec is a second-order random walk so the walker can carry a message with him for his next step. For node2vec, the messages contain the neighbors of the previous vertice so we can compute the dynamic component correctly."))}m.isMDXComponent=!0}}]);